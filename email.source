---------------------------------------------------------------------------
--
-- email.sql
--
-- COMP9315 Database Systems Imp 
-- Stuart Aitken, Gina Jordanova
-- Assignment 1 Adding an Email Data Type to PostgreSQL
--
-- src/tutorial/email.source
--
---------------------------------------------------------------------------

-- the input function 'email_in' takes the textual representation and
-- converts it into the internal representation.

CREATE FUNCTION email_in(cstring)
   RETURNS email
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;

-- the output function 'email_out' takes the internal representation and
-- converts it into the textual representation.

CREATE FUNCTION email_out(email)
   RETURNS cstring
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;

-- the binary input function 'email_recv' takes a StringInfo buffer
-- and turns its contents into the internal representation.

CREATE FUNCTION email_recv(internal)
   RETURNS email
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;

-- the binary output function 'email_send' takes the internal representation
-- and converts it into a (hopefully) platform-independent bytea string.

CREATE FUNCTION email_send(email)
   RETURNS bytea
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;


-- Type creation.

CREATE TYPE email (
   internallength = 16,
   input = email_in,
   output = email_out,
   receive = email_recv,
   send = email_send,
   alignment = string
);


-- Test suit

CREATE TABLE UserSessions (
    username EmailAddress,
    loggedIn timeStamp,
    loggedOut timeStamp
);

insert into Users(username,loggedIn,loggedOut) values
('jas@cse.unsw.edu.au','2012-07-01 15:45:55','2012-07-01 15:51:20'),
('jas@cse.unsw.EDU.AU','2012-07-01 15:50:30','2012-07-01 15:53:15'),
('z9987654@unsw.edu.au','2012-07-01 15:51:10','2012-07-01 16:01:05'),
('m.mouse@disney.com','2012-07-01 15:51:11','2012-07-01 16:01:06'),
('a-user@fast-money.com','2012-07-01 15:52:25','2012-07-01 16:10:15');

create index on UserSessions using hash (username);

select a.username, a.loggedIn, b.loggedIn
from   UserSessions a, UserSessions b
where  a.uname = b.uname and a.loggedIn <> b.loggedIn;

select path,count(*)
from   Users
group  by path;


-- define the required operators
CREATE FUNCTION email_lt(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION email_le(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION email_eq(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION email_noteq(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION email_gt(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION emails_ge(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION emails_deq(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
   
CREATE FUNCTION emails_notdeq(email, email) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;



CREATE OPERATOR < (
   leftarg = emails, rightarg = emails, procedure = emails_lt,
   commutator = > , negator = >= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
CREATE OPERATOR <= (
   leftarg = emails, rightarg = emails, procedure = emails_le,
   commutator = >= , negator = > ,
   restrict = scalarltsel, join = scalarltjoinsel
);
CREATE OPERATOR = (
   leftarg = emails, rightarg = emails, procedure = emails_eq,
   commutator = = , negator = <>,
   restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR <> (
   leftarg = emails, rightarg = emails, procedure = emails_noteq,
   commutator = <> , negator = =,
   restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR >= (
   leftarg = emails, rightarg = emails, procedure = emails_ge,
   commutator = <= , negator = < ,
   restrict = scalargtsel, join = scalargtjoinsel
);
CREATE OPERATOR > (
   leftarg = emails, rightarg = emails, procedure = emails_gt,
   commutator = < , negator = <= ,
   restrict = scalargtsel, join = scalargtjoinsel
);
CREATE OPERATOR ~ (
   leftarg = emails, rightarg = emails, procedure = emails_deq,
   commutator = ~ , negator = !~ ,
   restrict = scalargtsel, join = scalargtjoinsel
);
CREATE OPERATOR !~ (
   leftarg = emails, rightarg = emails, procedure = emails_notdeq,
   commutator = !~ , negator = ~ ,
   restrict = scalargtsel, join = scalargtjoinsel
);



-- make the operator class
CREATE OPERATOR CLASS email_ops
    DEFAULT FOR TYPE email USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        5       <> ,
        OPERATOR        5       >= ,
        OPERATOR        6       > ,
        OPERATOR        7       ~ ,
        OPERATOR        8       !~ ,


-- btree definitions
INSERT INTO test_email VALUES ('abc@test.com');
INSERT INTO test_email VALUES ('abc@test.com');

CREATE INDEX test_email_ind ON test_email
   USING btree(a email_ops);

SELECT * from test_email where a = 'abc@test.com';
SELECT * from test_email where a != 'abc@test.com';
SELECT * from test_email where a < 'abc@test.com';
SELECT * from test_email where a <= 'abc@test.com';
SELECT * from test_email where a > 'abc@test.com';
SELECT * from test_email where a >= 'abc@test.com';
SELECT * from test_email where a ~ 'abc@test.com';
SELECT * from test_email where a !~ 'abc@test.com';


-- clean up the example
DROP TABLE test_email;
DROP TYPE email CASCADE;


